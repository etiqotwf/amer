import { exec } from "child_process";
import fs from "fs";
import path from "path";
import sqlite3 from "sqlite3";
import { fileURLToPath } from "url";
import cliTable from "cli-table3";
import inquirer from "inquirer";
import chalk from "chalk";
import figlet from "figlet";
import boxen from "boxen";
import ora from "ora";
import terminalKit from "terminal-kit"; 
import gradient from "gradient-string";
import mammoth from "mammoth"; // ŸÖŸÉÿ™ÿ®ÿ© ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÜÿµŸàÿµ ŸÖŸÜ docx
import xlsx from "xlsx";
import pdfParse from "pdf-parse";
import { Document, Packer, Paragraph, TextRun } from "docx";
import { transliterate } from "transliteration";
import sharp from 'sharp';
import { PDFDocument } from 'pdf-lib'; // ÿ™ÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿµŸàÿ± ÿ•ŸÑŸâ PDF
import { c } from 'tar';

import crypto from 'crypto';

const tempDir = "temp"; // ŸÖÿ¨ŸÑÿØ ŸÖÿ§ŸÇÿ™ ŸÑŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± ÿßŸÑŸÖŸÑŸÅÿßÿ™


const encryptionKey = crypto.randomBytes(32); // Ÿäÿ¨ÿ® ÿ≠ŸÅÿ∏ Ÿáÿ∞ÿß ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ŸÑÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ŸÑÿßÿ≠ŸÇŸãÿß





const { terminal } = terminalKit; // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ `terminal`








// ÿ™ÿ≠ŸàŸäŸÑ fileURL ÿ•ŸÑŸâ path
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const dbPath = path.join(__dirname, 'archive.db');

// ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÇÿ®ŸÑ ŸÖÿ≠ÿßŸàŸÑÿ© ÿ≠ÿ∞ŸÅŸáÿß
const dbExists = fs.existsSync(dbPath);

// ŸÅÿ™ÿ≠ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
const db = new sqlite3.Database(dbPath, (err) => {
    if (err) return;

    // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ÿØŸàŸÑ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
    const createTableQuery = `
        CREATE TABLE IF NOT EXISTS archived_files (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            file_name TEXT NOT NULL,
            file_extension TEXT NOT NULL,
            file_size INTEGER NOT NULL,
            original_path TEXT NOT NULL,
            archived_path TEXT NOT NULL,
            archived_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `;

    db.run(createTableQuery, (err) => {
        if (err) return;

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑÿ£ÿπŸÖÿØÿ© encryption_key Ÿà encrypted_data
        db.all("PRAGMA table_info(archived_files);", (err, rows) => {
            if (err) return;

            const columns = rows.map(row => row.name);
            if (!columns.includes("encryption_key")) {
                db.run("ALTER TABLE archived_files ADD COLUMN encryption_key TEXT;", (err) => {
                    if (err) return;
                });
            }

            if (!columns.includes("encrypted_data")) {
                db.run("ALTER TABLE archived_files ADD COLUMN encrypted_data BLOB;", (err) => {
                    if (err) return;
                });
            }

            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ≥ÿ¨ŸÑÿßÿ™
            db.get(`SELECT COUNT(*) AS count FROM archived_files`, (err, row) => {
                if (err) return;

                if (row.count > 0) {
                    return;
                } else if (dbExists) {
                    db.run(`DELETE FROM archived_files`, (err) => {
                        if (err) return;

                        // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿπÿØÿßÿØ AUTOINCREMENT
                        db.run(`DELETE FROM sqlite_sequence WHERE name='archived_files'`, (err) => {
                            if (err) return;
                        });
                    });
                }
            });
        });
    });
});

// ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
const archiveDir = path.join(__dirname, 'archive');

if (!fs.existsSync(archiveDir)) {
    fs.mkdirSync(archiveDir);
}


// ÿØÿßŸÑÿ© ŸÑŸÅÿ™ÿ≠ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸàÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑÿ£ÿπŸÖÿØÿ© Ÿàÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ÿØŸàŸÑ
function manageDatabase() {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const dbPath = path.join(__dirname, 'archive.db');

    // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÇÿ®ŸÑ ŸÖÿ≠ÿßŸàŸÑÿ© ÿ≠ÿ∞ŸÅŸáÿß
    const dbExists = fs.existsSync(dbPath);

    // ŸÅÿ™ÿ≠ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    const db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
            console.error("‚ùå Error opening database:", err.message);
            return;
        }

        console.log("‚úÖ Database opened successfully.");

        // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ÿØŸàŸÑ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
        const createTableQuery = `
            CREATE TABLE IF NOT EXISTS archived_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                file_name TEXT NOT NULL,
                file_extension TEXT NOT NULL,
                file_size INTEGER NOT NULL,
                original_path TEXT NOT NULL,
                archived_path TEXT NOT NULL,
                archived_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `;

        db.run(createTableQuery, (err) => {
            if (err) {
                console.error("‚ùå Error creating table:", err.message);
                return;
            }

            console.log("‚úÖ Table 'archived_files' checked/created successfully.");

            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑÿ£ÿπŸÖÿØÿ© encryption_key Ÿà encrypted_data
            db.all("PRAGMA table_info(archived_files);", (err, rows) => {
                if (err) {
                    console.error("‚ùå Error checking table schema:", err.message);
                    return;
                }

                const columns = rows.map(row => row.name);
                if (!columns.includes("encryption_key")) {
                    db.run("ALTER TABLE archived_files ADD COLUMN encryption_key TEXT;", (err) => {
                        if (err) {
                            console.error("‚ùå Error adding encryption_key column:", err.message);
                        } else {
                            console.log("‚úÖ encryption_key column added successfully.");
                        }
                    });
                }

                if (!columns.includes("encrypted_data")) {
                    db.run("ALTER TABLE archived_files ADD COLUMN encrypted_data BLOB;", (err) => {
                        if (err) {
                            console.error("‚ùå Error adding encrypted_data column:", err.message);
                        } else {
                            console.log("‚úÖ encrypted_data column added successfully.");
                        }
                    });
                }

                // ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≥ÿ¨ŸÑÿßÿ™ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿ®ÿØŸàŸÜ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿπÿØÿØŸáÿß
                if (dbExists) {
                    console.log("üóëÔ∏è Deleting all entries...");

                    db.run(`DELETE FROM archived_files`, (err) => {
                        if (err) {
                            console.error("‚ùå Error deleting records:", err.message);
                            return;
                        }
                        console.log("‚úÖ All records deleted.");

                        // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿπÿØÿßÿØ AUTOINCREMENT
                        db.run(`DELETE FROM sqlite_sequence WHERE name='archived_files'`, (err) => {
                            if (err) {
                                console.error("‚ùå Error resetting AUTOINCREMENT:", err.message);
                            } else {
                                console.log("‚úÖ AUTOINCREMENT reset successfully.");
                            }
                        });

                        // ÿ≠ÿ∞ŸÅ ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ ÿ®ÿπÿØ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
                        const archiveDir = path.join(__dirname, 'archive');
                        if (fs.existsSync(archiveDir)) {
                            fs.rmSync(archiveDir, { recursive: true, force: true });
                            console.log(`‚úÖ Deleted archive directory: ${archiveDir}`);
                        }
                    });
                }
            });
        });
    });

    // ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
    const archiveDir = path.join(__dirname, 'archive');
    console.log(`üìÇ Archive directory: ${archiveDir}`);

    if (!fs.existsSync(archiveDir)) {
        fs.mkdirSync(archiveDir);
        console.log(`‚úÖ Created directory: ${archiveDir}`);
    }
    
    requestPassword();
     mainMenu();


}





function openFile(id) {
    db.get("SELECT archived_path, encryption_key FROM archived_files WHERE id = ?", [id], (err, row) => {
        if (err) {
            console.error("‚ùå Error retrieving file:", err.message);
            return;
        }

        if (!row) {
            console.log("‚ùå File not found.");
            return;
        }

        const encryptedFilePath = row.archived_path;
        const fileName = path.basename(encryptedFilePath, ".enc");
        const decryptedPath = path.join(archiveDir, fileName); // ÿßŸÑŸÖÿ≥ÿßÿ± ŸÑŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±

        const encryptionKey = Buffer.from(row.encryption_key, 'hex');
        try {
            const encryptedData = fs.readFileSync(encryptedFilePath);

            // ŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±
            const decipher = crypto.createDecipheriv("aes-256-cbc", encryptionKey, Buffer.alloc(16, 0));
            const decryptedData = Buffer.concat([decipher.update(encryptedData), decipher.final()]);

            fs.writeFileSync(decryptedPath, decryptedData);
            console.log(`‚úÖ File successfully decrypted: ${decryptedPath}`);

            // ŸÅÿ™ÿ≠ ÿßŸÑŸÖŸÑŸÅ
            exec(`"${decryptedPath}"`, (err) => {
                if (err) {
                    console.error("‚ùå Error opening file:", err);
                } else {
                    console.log("‚úÖ File opened successfully.");
                    
                    // ÿ®ÿπÿØ ÿ∫ŸÑŸÇ ÿßŸÑŸÖŸÑŸÅÿå ŸÜÿπŸäÿØ ÿ™ÿ¥ŸÅŸäÿ±Ÿá
                    // ŸÜŸÜÿ™ÿ∏ÿ± ÿ≠ÿ™Ÿâ Ÿäÿ™ŸÖ ÿ∫ŸÑŸÇ ÿßŸÑŸÖŸÑŸÅÿå ÿ´ŸÖ ŸÜŸÇŸàŸÖ ÿ®ÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ŸÅŸäÿ±Ÿá
                    encryptFileAndArchive(decryptedPath, encryptedFilePath, encryptionKey);
                }
            });
        } catch (err) {
            console.error("‚ùå Error decrypting the file:", err);
        }
    });
}

// ÿØÿßŸÑÿ© ŸÑÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ŸÅŸäÿ± ÿßŸÑŸÖŸÑŸÅ
function encryptFileAndArchive(decryptedPath, encryptedFilePath, encryptionKey) {
    try {
        const fileData = fs.readFileSync(decryptedPath);

        const cipher = crypto.createCipheriv("aes-256-cbc", encryptionKey, Buffer.alloc(16, 0));
        const encryptedData = Buffer.concat([cipher.update(fileData), cipher.final()]);

        // ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖÿ¥ŸÅÿ± ŸÖÿ¨ÿØÿØŸãÿß ŸÅŸä ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
        fs.writeFileSync(encryptedFilePath, encryptedData);
        console.log(`‚úÖ File successfully re-encrypted and archived: ${encryptedFilePath}`);

        // ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖŸÅŸÉŸàŸÉ ÿ®ÿπÿØ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±
        fs.unlinkSync(decryptedPath);
        console.log(`‚úÖ Deleted decrypted file: ${decryptedPath}`);
    } catch (err) {
        console.error("‚ùå Error encrypting the file for archiving:", err);
    }
}



async function searchFiles() {
    const { keyword } = await inquirer.prompt([
        {
            type: "input",
            name: "keyword",
            message: "üîç Enter search keyword (name, date, extension, path, or content):"
        }
    ]);

    const query = `
        SELECT * FROM archived_files 
        WHERE file_name LIKE ? 
        OR file_extension LIKE ? 
        OR archived_at LIKE ? 
        OR archived_path LIKE ?
    `;
    const params = Array(4).fill(`%${keyword}%`);

    try {
        let rows = await new Promise((resolve, reject) => {
            db.all(query, params, (err, results) => {
                if (err) reject(err);
                else resolve(results);
            });
        });

        if (rows.length === 0) {
            console.log(chalk.yellow("‚ö†Ô∏è No matching files found."));
            return;
        }

        let resultsText = `=======================================\n`;
        resultsText += `üìÇ üîç Search Results (${new Date().toLocaleString("en-US")}) - Total: ${rows.length} files\n`;
        resultsText += `=======================================\n\n`;

        const table = new cliTable({
            head: [
                chalk.white("üÜî ID"), chalk.white("üìú Name"), chalk.white("üóÇÔ∏è Ext"), chalk.white("üìè Size (KB)"), chalk.white("üìÖ Date Archived"), chalk.white("üìç Path")
            ],
            colWidths: [5, 25, 8, 12, 18, 50],
            wordWrap: true
        });

        for (let row of rows) {
            table.push([
                row.id,
                row.file_name,
                row.file_extension,
                (row.file_size / 1024).toFixed(2),
                row.archived_at,
                row.archived_path
            ]);

            resultsText += `üÜî ${row.id}\n`;
            resultsText += `üìú Name: ${row.file_name}\n`;
            resultsText += `üóÇÔ∏è Extension: ${row.file_extension}\n`;
            resultsText += `üìè Size: ${(row.file_size / 1024).toFixed(2)} KB\n`;
            resultsText += `üìÖ Date Archived: ${row.archived_at}\n`;
            resultsText += `üìç Path: ${row.archived_path}\n`;
            resultsText += `---------------------------------------\n`;
        }

        console.log(table.toString());

        // ÿ≠ŸÅÿ∏ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ŸÅŸä ŸÖŸÑŸÅ
        const fileName = "search_results.txt";
        fs.writeFileSync(fileName, resultsText, "utf8");
        console.log(chalk.blue(`üìÇ Search results saved in: ${fileName}`));

        // ÿπÿ±ÿ∂ ÿÆŸäÿßÿ± ŸÅÿ™ÿ≠ ÿßŸÑŸÖŸÑŸÅ
        const { openFile } = await inquirer.prompt([
            {
                type: "confirm",
                name: "openFile",
                message: "üìÑ Do you want to open the search results file?",
                default: false
            }
        ]);

        if (openFile) {
            exec(`"${fileName}"`, (err) => {
                if (err) {
                    console.error(chalk.red(`‚ùå Error opening file: ${fileName}`));
                }
            });
        }

    } catch (error) {
        console.error(chalk.red("‚ùå Error searching records:"), error.message);
    }
}

// ÿØÿßŸÑÿ© ŸÑŸÅÿ™ÿ≠ ŸÖÿ™ÿµŸÅÿ≠ ÿßŸÑŸÖŸÑŸÅÿßÿ™



export async function archiveFile(filePath) {
    const fileName = path.basename(filePath);
    const archivePath = path.join(archiveDir, fileName + ".enc");
    const fileExtension = path.extname(fileName).slice(1);
    const fileSize = fs.statSync(filePath).size;
    
    try {
        const fileData = fs.readFileSync(filePath);
        const cipher = crypto.createCipheriv("aes-256-cbc", encryptionKey, Buffer.alloc(16, 0));
        const encryptedData = Buffer.concat([cipher.update(fileData), cipher.final()]);
        
        fs.writeFileSync(archivePath, encryptedData);
        fs.unlinkSync(filePath); // ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ£ÿµŸÑŸä ÿ®ÿπÿØ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±

        console.log(`‚úÖ File successfully encrypted and archived: ${archivePath}`);

        db.run(
            `INSERT INTO archived_files (file_name, file_extension, file_size, original_path, archived_path, encryption_key, encrypted_data) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [fileName, fileExtension, fileSize, filePath, archivePath, encryptionKey.toString("hex"), encryptedData.toString("hex")],
            function (err) {
                if (err) {
                    console.error("‚ùå Error saving record to database:", err.message);
                } else {
                    console.log(`üìÇ File record saved in database (ID: ${this.lastID})`);
                }
            }
        );
    } catch (err) {
        console.error("‚ùå Error encrypting or moving the file:", err);
    }
}


// ÿØÿßŸÑÿ© ŸÑÿπÿ±ÿ∂ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ§ÿ±ÿ¥ŸÅÿ© ŸÅŸä ÿ¨ÿØŸàŸÑ
async function listArchivedFiles() {
    const spinner = ora("üì¶ Fetching archived files...").start();

    db.all("SELECT * FROM archived_files", (err, rows) => {
        if (err) {
            spinner.fail("‚ùå Error fetching records: " + err.message);
            return;
        }

        spinner.succeed(`üîç Retrieved ${rows.length} rows.`);

        if (rows.length === 0) {
            console.log("üìÇ No archived files found.");
            return;
        }

        // ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿØŸàŸÜ ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿ£ÿµŸÑŸäÿ©
        const tableData = rows.map(row => ([
            row.id?.toString() || "",
            row.file_name || "",
            row.file_extension || "", // ÿπÿ±ÿ∂ ÿßŸÑÿßŸÖÿ™ÿØÿßÿØ ŸÉŸÖÿß ŸáŸà ÿ®ÿØŸàŸÜ ÿ™ÿπÿØŸäŸÑ
            row.file_size ? (row.file_size / 1024).toFixed(2) + " KB" : "", // ÿπÿ±ÿ∂ ÿßŸÑÿ≠ÿ¨ŸÖ ŸÉŸÖÿß ŸáŸà
            row.archived_at || "",
            row.archived_path || ""
        ]));

        // ÿπÿ±ÿ∂ ÿßŸÑÿ¨ÿØŸàŸÑ
        terminal.clear();
        terminal.table(
            [["ID", "Name", "Extension", "Size (KB)", "Date Archived", "Path"], ...tableData],
            {
                hasBorder: true,
                borderChars: "lightRounded",
                width: terminal.width - 2,
                fit: true
            }
        );

        terminal("\nUse ‚Üë ‚Üì to scroll, Press 'q' to exit.\n");

        // ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ŸÑŸàÿ≠ÿ© ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠
        terminal.grabInput({ mouse: "button" });

        terminal.on("key", (key) => {
            if (key === "q") {
                terminal("\nExiting...\n");
                process.exit();
            }
        });
    });
}


// ÿØÿßŸÑÿ© ŸÑÿ≠ÿ∞ŸÅ ŸÖŸÑŸÅ ŸÖŸÜ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ Ÿàÿ•ÿπÿßÿØÿ™Ÿá ÿ•ŸÑŸâ ŸÖÿ≥ÿßÿ±Ÿá ÿßŸÑÿ£ÿµŸÑŸä
async function restoreFile(id) {
    db.get("SELECT * FROM archived_files WHERE id = ?", [id], async (err, row) => {
        if (err) {
            console.error("‚ùå Error retrieving file:", err.message);
            return;
        }

        if (!row) {
            console.log("‚ùå File not found.");
            return;
        }

        const encryptedPath = row.archived_path;  // ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑŸÖÿ¥ŸÅÿ±
        const originalPath = row.original_path;  // ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ£ÿµŸÑŸä ŸÑŸÑŸÖŸÑŸÅ
        const encryptionKey = Buffer.from(row.encryption_key, 'hex'); // ŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±

        try {
            // ŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ± ÿ•ŸÑŸâ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ£ÿµŸÑŸä
            await decryptFile(encryptedPath, originalPath, encryptionKey);

            // ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖÿ¥ŸÅÿ± ÿ®ÿπÿØ ŸÜÿ¨ÿßÿ≠ ŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±
            fs.unlinkSync(encryptedPath);

            // ÿ≠ÿ∞ŸÅ ÿßŸÑÿ≥ÿ¨ŸÑ ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
            db.run("DELETE FROM archived_files WHERE id = ?", [id], (err) => {
                if (err) {
                    console.error("‚ùå Error deleting record:", err.message);
                } else {
                    console.log(`‚úÖ File restored successfully and decrypted: ${originalPath}`);
                }
            });
        } catch (err) {
            console.error("‚ùå Error restoring file:", err);
        }
    });
}


// ÿØÿßŸÑÿ© ŸÑÿ≠ÿ∞ŸÅ ŸÖŸÑŸÅ ŸÜŸáÿßÿ¶ŸäŸãÿß ŸÖŸÜ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ ŸàŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
async function deleteFile(id) {
    db.get("SELECT archived_path FROM archived_files WHERE id = ?", [id], async (err, row) => {
        if (err) {
            console.error("‚ùå Error retrieving file:", err.message);
            return;
        }

        if (!row) {
            console.log("‚ùå File not found.");
            return;
        }

        // ÿ∑ŸÑÿ® ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÇÿ®ŸÑ ÿßŸÑÿ≠ÿ∞ŸÅ
        const { confirm } = await inquirer.prompt([
            {
                type: "confirm",
                name: "confirm",
                message: chalk.red(`‚ö†Ô∏è Are you sure you want to delete this file permanently?`),
                default: false,
            },
        ]);

        if (!confirm) {
            console.log("üö´ Deletion cancelled.");
            return;
        }

        try {
            fs.unlinkSync(row.archived_path);
            db.run("DELETE FROM archived_files WHERE id = ?", [id], (err) => {
                if (err) {
                    console.error("‚ùå Error deleting record:", err.message);
                } else {
                    console.log("‚úÖ File deleted permanently.");
                }
            });
        } catch (err) {
            console.error("‚ùå Error deleting file:", err);
        }
    });
}



function printTitle() {
    console.clear();
    
    console.log(
        gradient.pastel.multiline(
            figlet.textSync("File Manager", { 
                font: "Big",
                horizontalLayout: "full",
                verticalLayout: "default"
            })
        )
    );

    console.log(
        boxen(chalk.bold.white(" Welcome to the File Management System!"), { 
            padding: 1,  
            margin: .5,  
            backgroundColor: "black",
            borderStyle: "bold", 
            borderColor: "cyan", 
            align: "center"
        })
    );

    // ÿ¨ŸÑÿ® ÿßŸÑŸàŸÇÿ™ ŸàÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ≠ÿßŸÑŸä
    const now = new Date();
    const formattedTime = now.toLocaleTimeString('en-GB'); // HH:mm:ss
    const formattedDate = now.toLocaleDateString('en-GB'); // DD/MM/YYYY
    const timeAndDate = ` ${formattedTime}  ${formattedDate}`;

    // ÿ¨ŸÑÿ® ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸÖŸÜ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
    const archiveStats = getArchiveStats();
    let statsMessage = "";

    if (archiveStats) {
        statsMessage = ` Total: ${archiveStats.total} | PDF: ${archiveStats.types.pdf} | DOCX: ${archiveStats.types.docx} | TXT: ${archiveStats.types.txt} | Excel: ${archiveStats.types.xlsx + archiveStats.types.xls} | Images: ${archiveStats.types.jpg + archiveStats.types.jpeg} | Other: ${archiveStats.types.other}`;
    } else {
        statsMessage = " No files found in archive.";
    }

    // ÿ∑ÿ®ÿßÿπÿ© ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿ®ÿ¨ÿßŸÜÿ® ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸàÿßŸÑŸàŸÇÿ™
    console.log(
        boxen(
            chalk.bold.yellow(`${statsMessage} | ${timeAndDate}`), {
                padding: .5,
                margin: 1,
                backgroundColor: "black",
                borderStyle: "bold",
                borderColor: "cyan",
                align: "center"
            }
        )
    );

    console.log(
        chalk.underline(
            gradient(['#FF4500', '#FFA500', '#FFFF00'])(" Designed by Ahmed Amer\n")
        )
    );
}

// ŸÖÿ≥ÿßÿ± ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
const archiveDirectory = path.resolve(__dirname, 'archive');  // ÿßÿ≥ÿ™ÿ®ÿØŸÑ Ÿáÿ∞ÿß ÿ®ŸÖÿ≥ÿßÿ± ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ ÿßŸÑŸÅÿπŸÑŸä ŸÑÿØŸäŸÉ

// ÿØÿßŸÑÿ© ŸÑÿ•ÿ≠ÿ∂ÿßÿ± ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
function getArchiveStats() {
    const archiveFiles = getArchiveFiles(); // ÿ¨ŸÑÿ® ÿßŸÑŸÖŸÑŸÅÿßÿ™ ŸÖŸÜ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
    if (archiveFiles.length === 0) {
        return null;
    }

    // ÿ™ÿµŸÜŸäŸÅ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿ≠ÿ≥ÿ® ÿßŸÑŸÜŸàÿπ
    const fileTypes = {
        pdf: 0,
        docx: 0,
        txt: 0,
        xlsx: 0,
        xls: 0,
        jpg: 0,
        jpeg: 0,
        other: 0
    };

    // ÿ™ÿµŸÜŸäŸÅ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿ≠ÿ≥ÿ® ÿßŸÑŸÜŸàÿπ
    archiveFiles.forEach(file => {
        // ÿ•ÿ≤ÿßŸÑÿ© Ÿàÿ≥ŸÖ 'enc' ÿ•ŸÜ Ÿàÿ¨ÿØ
        const originalName = file.replace(/\.enc$/, '');  
        const ext = path.extname(originalName).toLowerCase();

        if (ext === '.pdf') fileTypes.pdf++;
        else if (ext === '.docx') fileTypes.docx++;
        else if (ext === '.txt') fileTypes.txt++;
        else if (ext === '.xlsx') fileTypes.xlsx++;
        else if (ext === '.xls') fileTypes.xls++;
        else if (ext === '.jpg') fileTypes.jpg++;
        else if (ext === '.jpeg') fileTypes.jpeg++;
        else fileTypes.other++;
    });

    return {
        total: archiveFiles.length,
        types: fileTypes
    };
}

// ÿØÿßŸÑÿ© ŸÑÿ•ÿ≠ÿ∂ÿßÿ± ÿßŸÑŸÖŸÑŸÅÿßÿ™ ŸÖŸÜ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
function getArchiveFiles() {
    try {
        // ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑŸÖŸÑŸÅÿßÿ™ ŸÖŸÜ ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
        const files = fs.readdirSync(archiveDirectory);
        return files.filter(file => fs.statSync(path.join(archiveDirectory, file)).isFile());
    } catch (err) {
        console.error(chalk.red('Error reading archive directory:', err));
        return [];
    }
}





async function requestPassword() {
    const correctPassword = "1234"; // ŸÇŸÖ ÿ®ÿ™ÿ∫ŸäŸäÿ±Ÿáÿß ÿ≠ÿ≥ÿ® ÿßŸÑÿ≠ÿßÿ¨ÿ©
    const { password } = await inquirer.prompt([
        {
            type: "password",
            name: "password",
            message: chalk.green("üîë Please Enter Password :  "),
            mask: "*"
        }
    ]);

    if (password !== correctPassword) {
        console.log(chalk.yellowBright("‚ùå Wrong Password "));
        process.exit();
    }
}




async function convertImageToPdf(imagePath, pdfPath) {
    const image = await sharp(imagePath).toBuffer();
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage([600, 800]);
    const img = await pdfDoc.embedJpg(image);
    page.drawImage(img, { x: 0, y: 0, width: page.getWidth(), height: page.getHeight() });
    const pdfBytes = await pdfDoc.save();
    fs.writeFileSync(pdfPath, pdfBytes);
    console.log(`‚úÖ Image converted to PDF: ${pdfPath}`);
}

async function convertPdfToDocx(pdfPath) {
    if (!fs.existsSync(pdfPath)) {
        console.error(`‚ùå Error: The file is not found at the path: ${pdfPath}`);
        return;
    }

    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖŸÑŸÅ ÿµŸàÿ±ÿ©ÿå ÿ≥Ÿäÿ™ŸÖ ÿ™ÿ≠ŸàŸäŸÑŸá ÿ£ŸàŸÑÿßŸã ÿ•ŸÑŸâ PDF
    const extname = path.extname(pdfPath).toLowerCase();
    if (['.jpg', '.jpeg', '.png', '.gif', '.bmp'].includes(extname)) {
        const tempPdfPath = pdfPath.replace(extname, '.pdf');
        await convertImageToPdf(pdfPath, tempPdfPath);
        pdfPath = tempPdfPath; // ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ ÿßŸÑŸÖÿ≥ÿßÿ± ÿ®ÿßŸÑŸÄ PDF ÿßŸÑŸÖÿ≠ŸàŸÑ
    }

    const outputDocxPath = pdfPath.replace(/\.pdf$/, ".docx");
    const pdfBuffer = fs.readFileSync(pdfPath);
    const data = await pdfParse(pdfBuffer);
    const extractedText = data.text.trim();
    const paragraphs = extractedText.split("\n").filter(p => p.trim() !== "");

    const doc = new Document({
        sections: [{
            properties: {},
            children: paragraphs.map(paragraph => {
                const isTitle = paragraph.includes(":") || paragraph.split(" ").length <= 5;
                return new Paragraph({
                    bidirectional: true,
                    children: [
                        new TextRun({
                            text: paragraph,
                            bold: isTitle,
                            size: isTitle ? 32 : 26,
                            font: "Arial",
                        }),
                    ],
                    spacing: { after: isTitle ? 250 : 150 },
                });
            }),
        }],
    });

    const docBuffer = await Packer.toBuffer(doc);
    fs.writeFileSync(outputDocxPath, docBuffer);
    console.log(`‚úÖ Conversion successful: ${outputDocxPath}`);
}






async function mainMenu() {
    printTitle();

    while (true) {
        const { action } = await inquirer.prompt([  
            {
                type: "list",
                name: "action",
                prefix: " ",
                message: "", // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ´ÿßÿ®ÿ™ÿ© ŸáŸÜÿß
                choices: [
                    { key: "A", name: "\x1b[1m\x1b[33m[1] [A] Archive a file\x1b[0m", value: "archive" },
                    { key: "L", name: "\x1b[1m\x1b[36m[2] [L] List archived files\x1b[0m", value: "list" },
                    { key: "S", name: "\x1b[1m\x1b[38;5;10m[3] [S] Search for files\x1b[0m", value: "search" },
                    { key: "SI", name: "\x1b[1m\x1b[38;5;214m[4] [SI] Search inside a file\x1b[0m", value: "searchInside" },
                    { key: "C", name: "\x1b[1m\x1b[38;5;49m[5] [C] Convert PDF ‚Üî DOCX\x1b[0m", value: "convert" },
                    { key: "O", name: "\x1b[1m\x1b[38;5;223m[6] [O] Open a file\x1b[0m", value: "open" },
                    { key: "R", name: "\x1b[1m\x1b[35m[7] [R] Restore a file\x1b[0m", value: "restore" },
                    { key: "X", name: "\x1b[1m\x1b[38;5;220m[8] [X] Delete a file\x1b[0m", value: "delete" },
                    { key: "B", name: "\x1b[1m\x1b[38;5;203m[9] [B] Backup the archive folder\x1b[0m", value: "backup" },
                    { key: "DB", name: "\x1b[1m\x1b[38;5;202m[10] [DB] Restore database\x1b[0m", value: "restoreDatabase" }, // ÿ•ÿ∂ÿßŸÅÿ© Ÿáÿ∞ÿß ÿßŸÑÿÆŸäÿßÿ±
                    { key: "E", name: "\x1b[1m\x1b[37m[x] [E] Exit\x1b[0m", value: "exit" }
                ],
                pageSize: 10,
                loop: false,
                transformer: (choice, { isSelected }) =>
                    isSelected ? chalk.bgBlack.yellow(`‚Üí ${choice}`) : chalk.bold.yellowBright(choice),
            },
        ]);

        // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸàÿ∏ÿßÿ¶ŸÅ ÿßŸÑŸÖÿÆÿ™ŸÑŸÅÿ©
        if (action === "archive") {
            await openFilePicker(archiveFile);
        } else if (action === "list") {
            listArchivedFiles();
        } else if (action === "search") {
            await searchFiles();
        } else if (action === "searchInside") {
            await searchInsideFile();
        } else if (action === "convert") {
            await openFilePicker(convertPdfToDocx);
        } else if (action === "open") {
            const { id } = await inquirer.prompt([{ type: "input", name: "id", message: chalk.blue("üñ•Ô∏è Enter file ID to open:") }]);
            openFile(parseInt(id));
        } else if (action === "restore") {
            const { id } = await inquirer.prompt([{ type: "input", name: "id", message: chalk.yellow("üîÑ Enter file ID to restore:") }]);
            restoreFile(parseInt(id));
        } else if (action === "delete") {
            const { id } = await inquirer.prompt([{ type: "input", name: "id", message: chalk.red("‚ö†Ô∏è Enter file ID to delete:") }]);
            deleteFile(parseInt(id));
        } else if (action === "backup") {
            const { backup } = await inquirer.prompt([
                {
                    type: 'confirm',
                    name: 'backup',
                    message: 'Do you want to create a backup of the archive folder before exit? (yes/no)',
                    default: false,
                },
            ]);

            if (backup) {
                const archiveFolderPath = path.join(__dirname, 'archive'); // Path to archive folder
                const backupFolderPath = 'G:/Backup/ArchiveBackup'; // Path where backup will be stored
                const backupFilePath = path.join(backupFolderPath, 'archive_backup.tar.gz');

                // Ensure backup folder exists
                if (!fs.existsSync(backupFolderPath)) {
                    fs.mkdirSync(backupFolderPath, { recursive: true });
                }

                // Create the tar backup
                try {
                    await c(
                        {
                            gzip: true, 
                            file: backupFilePath,
                            cwd: path.dirname(archiveFolderPath),
                        },
                        [path.basename(archiveFolderPath)]
                    );
                    console.log(chalk.green(`Backup created successfully at ${backupFilePath}`));
                } catch (error) {
                    console.error(chalk.red(`Error creating backup: ${error.message}`));
                }
            }
        } else if (action === "restoreDatabase") { // ŸáŸÜÿß ÿ™ÿ≠ŸÇŸÇŸÜÿß ŸÖŸÜ ÿßŸÑÿÆŸäÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ
            const { restoreDb } = await inquirer.prompt([{
                type: 'confirm',
                name: 'restoreDb',
                message: 'Do you want to restore the database? (yes/no)',
                default: false,
            }]);

            if (restoreDb) {
                console.log(chalk.yellow("Restoring the database..."));
                manageDatabase(); // ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑÿØÿßŸÑÿ© manageDatabase ŸáŸÜÿß
            }
        } else {
            console.log(chalk.magenta("\nüëã Exiting... Have a great day!\n"));
            process.exit();
        }

        // ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ≠ ŸÑŸÑÿ¥ÿßÿ¥ÿ© ŸáŸÜÿßÿå ŸÅŸÇÿ∑ ŸÜÿπÿ±ÿ∂ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÉŸÖÿß ŸáŸä.
        console.log(chalk.blue('Returning to the main menu...'));
    }
}




async function openFilePicker(callback) {
    console.log("üìÇ Please select a file...");

    let command;
    if (process.platform === "win32") {
        command =
            'powershell -Command "chcp 65001; [System.Reflection.Assembly]::LoadWithPartialName(\'System.Windows.Forms\');$f = New-Object System.Windows.Forms.OpenFileDialog;$f.Filter = \'All Files (*.*)|*.*\';$f.ShowDialog() | Out-Null;$f.FileName"';
    } else if (process.platform === "darwin") {
        command = `osascript -e 'tell application "Finder" to choose file'`;
    } else {
        command = "zenity --file-selection";
    }

    exec(command, { encoding: "utf8" }, (error, stdout) => {
        if (error) {
            console.error("‚ùå Error selecting file:", error.message);
            return;
        }

        let filePath = stdout
            .split(/\r?\n/)
            .map(line => line.trim())
            .filter(line => line && !line.includes("---") && !line.includes("GAC"))
            .pop();

        if (!filePath) {
            console.log("‚ùå No file selected.");
            return;
        }

        filePath = decodeURIComponent(filePath);

        if (!fs.existsSync(filePath)) {
            console.error("‚ùå File not found:", filePath);
            return;
        }

        const fileDir = path.dirname(filePath);
        const fileExt = path.extname(filePath);
        const originalFileName = path.basename(filePath, fileExt);

        // üîπ ÿ™ÿ≠ŸàŸäŸÑ ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ ÿ•ŸÑŸâ ŸÉŸÑŸÖÿ© ÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© Ÿàÿßÿ≠ÿØÿ© ÿ®ÿØŸàŸÜ ŸÅŸàÿßÿµŸÑ ÿ£Ÿà ÿπŸÑÿßŸÖÿßÿ™
        let newFileName = transliterate(originalFileName).replace(/[^a-zA-Z0-9]/g, "");
        if (!newFileName) newFileName = "ConvertedFile"; // ÿ™ÿ¨ŸÜÿ® ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÅÿßÿ±ÿ∫
        const newFilePath = path.join(fileDir, newFileName + fileExt);

        fs.rename(filePath, newFilePath, (err) => {
            if (err) {
                console.error("‚ùå Error renaming file:", err.message);
                return;
            }
            console.log("‚úÖ File renamed to:", newFilePath);
            callback(newFilePath);
        });
    });
}




async function extractTextFromFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    let text = "";

    try {
        if (ext === ".docx") {
            const { value } = await mammoth.extractRawText({ path: filePath });
            text = value.toLowerCase();
        } else if (ext === ".xlsx") {
            const workbook = xlsx.readFile(filePath);
            const sheetNames = workbook.SheetNames;
            sheetNames.forEach(sheet => {
                const sheetData = xlsx.utils.sheet_to_json(workbook.Sheets[sheet], { header: 1 });
                text += sheetData.flat().join(" ").toLowerCase() + " ";
            });
        } else if ([".jpg", ".jpeg", ".png"].includes(ext)) {
            const { data: { text: ocrText } } = await recognize(filePath);
            text = ocrText.toLowerCase();
        } else {
            console.warn(`‚ö†Ô∏è Unsupported file type: ${filePath}`);
        }
    } catch (error) {
        console.error(`‚ùå Error processing file ${filePath}:`, error.message);
    }

    return text;
}



if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir); // ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ¨ŸÑÿØ ŸÖÿ§ŸÇÿ™ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß

async function searchInsideFile() {
    try {
        const { keywords } = await inquirer.prompt([
            { type: 'input', name: 'keywords', message: chalk.cyan('üîç Enter keywords (comma-separated):') }
        ]);

        const keywordsArray = keywords.split(',').map(k => k.trim().toLowerCase()); // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿ•ŸÑŸâ lowercase

        let foundFiles = [];

        const files = await getEncryptedFiles(); // ÿ¨ŸÑÿ® ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ¥ŸÅÿ±ÿ© ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™

        for (const { id, encryptedFilePath, encryptionKey, originalFileName } of files) {
            const decryptedPath = path.join('archive', originalFileName); // ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ temp ÿ®ŸÄ archive

            try {
                await decryptFile(encryptedFilePath, decryptedPath, encryptionKey); // ŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±

                // ‚úÖ ÿ™ÿÆÿ∑Ÿä ÿßŸÑÿµŸàÿ± ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß
                if (/\.(jpg|jpeg|png|gif|bmp)$/i.test(originalFileName)) {
                    continue; // ŸÑÿß ÿ™ÿ≠ÿßŸàŸÑ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÜÿµ ŸÖŸÜ ÿßŸÑÿµŸàÿ±
                }

                let text = "";
                try {
                    text = await extractTextFromFile(decryptedPath); 
                    text = text.toLowerCase();
                } catch (error) {
                    continue; // ÿ™ÿ¨ÿßŸáŸÑ ÿ£Ÿä ÿÆÿ∑ÿ£ ŸàÿπÿØŸÖ ÿ∑ÿ®ÿßÿπÿ© ÿ¥Ÿäÿ°
                }

                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÖÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ŸÖŸàÿ¨ŸàÿØÿ©
                const allKeywordsFound = keywordsArray.every(keyword => text.includes(keyword));

                if (allKeywordsFound) {
                    console.log(chalk.green(`‚úÖ Keywords found in: ${originalFileName}`));
                    foundFiles.push(originalFileName);

                    // ÿπÿ±ÿ∂ ÿ™ŸÅÿßÿµŸäŸÑ ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÑŸÑŸÖŸÑŸÅ
                    const stats = fs.statSync(decryptedPath); // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖŸÑŸÅ
                    const fileSize = (stats.size / 1024).toFixed(2); // ÿßŸÑÿ≠ÿ¨ŸÖ ÿ®ÿßŸÑŸÄ KB
                    const folderPath = path.dirname(decryptedPath); // ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ£ÿµŸÑŸä ŸÑŸÑŸÅŸàŸÑÿØÿ±

                    // ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ ÿ®ÿ¨ÿßŸÜÿ® ÿ®ÿπÿ∂Ÿáÿß
                    console.log(chalk.cyan(`--- File Details ---`));
                    console.log(chalk.yellow(`ID: ${id}  |  Name: ${originalFileName}  |  Folder: ${folderPath}  |  Size: ${fileSize} KB`));
                    console.log(chalk.cyan(`--------------------`));
                }
            } catch (error) {
                // ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
            } finally {
                // ÿ≠ÿ∞ŸÅ ÿßŸÑŸÜÿ≥ÿÆÿ© ÿßŸÑŸÖŸÅŸÉŸàŸÉ ÿ™ÿ¥ŸÅŸäÿ±Ÿáÿß ÿ®ÿπÿØ ÿßŸÑÿ®ÿ≠ÿ´ ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑÿ£ŸÖÿßŸÜ
                if (fs.existsSync(decryptedPath)) {
                    fs.unlinkSync(decryptedPath);
                }
            }
        }

        if (foundFiles.length === 0) {
            console.log(chalk.red('‚ùå No matches found for the given keywords.'));
        }
    } catch (error) {
        console.error(chalk.red("‚ùå Error:"), error.message);
    }
}


// üîπ ÿØÿßŸÑÿ© ŸÑÿ¨ŸÑÿ® ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ¥ŸÅÿ±ÿ© ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
function getEncryptedFiles() {
    return new Promise((resolve, reject) => {
        db.all("SELECT id, archived_path, encryption_key FROM archived_files", [], (err, rows) => {
            if (err) {
                reject(err);
            } else {
                const files = rows.map(row => ({
                    id: row.id,  // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÄ ID
                    encryptedFilePath: row.archived_path,
                    encryptionKey: Buffer.from(row.encryption_key, 'hex'),
                    originalFileName: path.basename(row.archived_path, ".enc")
                }));
                resolve(files);
            }
        });
    });
}


// üîπ ÿØÿßŸÑÿ© ŸÑŸÅŸÉ ÿ™ÿ¥ŸÅŸäÿ± ÿßŸÑŸÖŸÑŸÅÿßÿ™ ŸÖÿ§ŸÇÿ™Ÿãÿß ŸÑŸÑÿ®ÿ≠ÿ´ ŸÅŸäŸáÿß
function decryptFile(encryptedFilePath, decryptedPath, encryptionKey) {
    try {
        const encryptedData = fs.readFileSync(encryptedFilePath);
        const decipher = crypto.createDecipheriv("aes-256-cbc", encryptionKey, Buffer.alloc(16, 0));
        const decryptedData = Buffer.concat([decipher.update(encryptedData), decipher.final()]);

        fs.writeFileSync(decryptedPath, decryptedData);
    } catch (err) {
        throw err; // ŸÑŸÜ ŸÜÿ∑ÿ®ÿπ ÿ£Ÿä ÿ¥Ÿäÿ° ÿπŸÜÿØ ÿ≠ÿØŸàÿ´ ÿÆÿ∑ÿ£
    }
}

async function startApp() {
    await requestPassword();
    await mainMenu();
}

// ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨
startApp();